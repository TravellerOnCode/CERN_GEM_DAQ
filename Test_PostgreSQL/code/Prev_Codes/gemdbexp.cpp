/*

CLASSES:
        1. component_name //each component type will have a class of their own
                    Like:
                        vfat class will have vfat columns as their class members

        2. postgre_database  //this will contain functions that will interact with the components

NOTE: CURRENTLY WE ARE UNABLE TO RESOLVE HOW TO WORK WITH  ARRAY VALUES WITH LIBPQXX SO WE ARE USING
EMPLOYEE DATABASE EXAMPLE TO EXPLAIN THE WORKFLOW & CODE


Class: component_name{

    Class variables:
        * int ID,SALARY,AGE;
        * string NAME,ADDRESS;

    Functions:
        * display_row() // displays the values of class vars
        * initialize( ...... ) //takes values and initializes the class vars
        * insert_row() //takes an object and inserts the values into the database
        * insert_data() //takes a vector of objects and inserts the values into the database
        * display_results() //displays the contents of the vector of objects
        * row_to_object() //takes the query response generated by query_response() function and converts
                              it into an vector of objects
}

Class:

    Functions:
        * query_response() //Accepts a query and returns the raw reponse which can be processed
                              by other functions from any component class


*/


//-----------

#include <iostream>
#include <pqxx/pqxx> 
#include <string>
#include <bits/stdc++.h>

//------------

using namespace std;
using namespace pqxx;

string DBNAME = "gemdaq";
string USER = "postgres";
string PASSWORD = "linuxos16";

//--------------

class component_name
{
    public:

        //to be used with original database
        long cernid;
        vector<int> vfat_settings; //(128,0);
        string settings;
        
    //Display a particular row of the table
    void display_row()
    {

        cout << "CERN ID: " << this->cernid << endl;
        cout << "DATA: " << this->settings << endl;
        cout << "DATA ARRAY: " << endl;
        for (auto it = this->vfat_settings.begin(); it != this->vfat_settings.end(); ++it) 
        cout << ' ' << *it << ',';
        
    }

    //Initialize an object with values
    void initialize(int id,string name, int age, int salary,string address)
    {
        
        this->cernid = cernid;
        this->settings = settings;
    }

    /*

    //Insert the values in the database from a single object
    void insert_row(connection *C, string table_name)
    {
        work WW(*C);
        string sql = "INSERT INTO COMPANY(ID,NAME,AGE,ADDRESS,SALARY) VALUES ("+ \
                    to_string(this->ID) + ", '"+to_string(this->NAME)+"', "+ \
                    to_string(this->AGE)+", '"+to_string(this->ADDRESS)+"', "+ \
                    to_string(this->SALARY)+");";
        
        WW.exec(sql);
        WW.commit();
        cout << "Values inserted !" << endl;
    }

    //Insert values into the database from a vector of objects
    void insert_data(connection *C, vector<component_name> data)
    {
        int i;
        for (i=0;i<data.size();i++)
        {
            data[i].insert_row(&(*C),"gemlong");
        }
    }
    */

    //Display results 
    void display_results(vector<component_name> &data)
    {
        int i;
        for (i=0;i<data.size();i++)
        {
            data[i].display_row();
            cout << "------" << endl << endl;
            break;
        }
    }

    
    //Returns a vector of objects from a query response
    vector<component_name> row_to_object(result R)
    {
        vector<component_name> query_results;

        for (auto const &row: R)
        {
            component_name obj;
            
            obj.cernid = stoi(row["cernid"].c_str());
            //obj.cernid = row["cernid"].as<long>();
            string str = row["data"].c_str();

            obj.settings = str;
            str = str.substr(1,str.length());
                        
            stringstream ss(str);
            while (ss.good()) {
                string sub;
                getline(ss, sub, ',');
                int d = stoi(sub);

                obj.vfat_settings.push_back(d);
            }
            

            //obj.display_row();
            query_results.push_back(obj);
        }
        //display_results(query_results);
        return query_results;
    }
    

};

class postgre_database  // : public component_name //-- hiding the imheritange for the moment
{
    public:

    //Returns the query response of a query 
    result query_response(connection *C,string table_name)
    {
            work WW(*C);
            string query = "SELECT * FROM " + table_name +";";

             result r = WW.exec(query);
             /*
             for (auto const &row: r)
             {
                //cout << row["ID"].c_str() << "   " << row["NAME"].c_str();
                for (auto const &field: row) 
                        std::cout << field.c_str() << '\t';
                std::cout << std::endl;
             }
              cout << "Table displayed successfully" << endl;
              */
              return r;
    }
};

int main()
{
    try
        {
            connection C("dbname = " + DBNAME + " user = "+ USER +" password = "+ PASSWORD +" \
                hostaddr = 127.0.0.1 port = 5432");
            if (C.is_open()) {
                   cout << "Opened database successfully: " << C.dbname() << endl;
             } 
             else {
                     cout << "Can't open database" << endl;
                     return 1;
              }

              postgre_database ob;
              result r;

              component_name obj;
              
              r = ob.query_response(&C,"gemlong");
              vector<component_name> results;
              //RETURNS A VECTOR OF OBJECTS
              results = obj.row_to_object(r);
              obj.display_results(results);
              

              C.disconnect ();
        }
        catch(const std::exception& e)
        {
            cerr << e.what() << std::endl;
        }

    return 0;
}